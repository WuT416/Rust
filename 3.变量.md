### 变量不可变
Rust的变量在默认情况下是不可变的。错误示例：
```
fn main() {
    let x = 5;
    x = 6;
    println!("The value of x is: {}", x);
}
```
let定义的变量虽然不可变，但是与我们之前学过的常量还是有所区别：
* 常量不允许使用 mut。常量不仅仅默认不可变，而且自始至终不可变，因为常量在编译完成后，已经确定它的值。
* 常量使用 const 关键字而不是 let 关键字来声明，并且值的类型必须标注。

### 可变变量
可以通过 mut 关键字让变量变为可变的，让设计更灵活。
```
fn main() {
    let mut x = 5;
    x = 6;
    println!("The value of x is: {}", x);
}
```

### 未使用的代码
如果你创建了一个变量却不在任何地方使用它，Rust 通常会给你一个警告，因为这可能会是个 BUG。但是有时创建一个不会被使用的变量是有用的，比如你正在设计原型或刚刚开始一个项目。这时你希望告诉 Rust 不要警告未使用的变量，为此可以用下划线作为变量名的开头：
```
fn main() {
    let _x = 5;
}
```

### 解构式赋值
解构赋值时，可使用_作为某个变量的占位符，使用..作为剩余所有变量的占位符
```
struct Struct {
    e: i32
}

fn main() {
    let (a, b, c, d, e);

    (a, b) = (1, 2);
    // _ 代表匹配一个值，但是我们不关心具体的值是什么，因此没有使用一个变量名而是使用了 _
    [c, .., d, _] = [1, 2, 3, 4, 5];
    Struct { e, .. } = Struct { e: 5 };

    assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);
}
```
### 变量遮蔽(shadowing)
Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的
